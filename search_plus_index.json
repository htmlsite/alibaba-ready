{"./":{"url":"./","title":"Introduction","keywords":"","body":"alibaba-ready Are you ready 进军阿里开始 Copyright © xuegangliu 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-02-26 18:19:34 "},"database/":{"url":"database/","title":"database-数据库","keywords":"","body":"Database memcached memcache_base.md mongo mysql oracle oracle_base.md oracle_funs.md oracle_system.md quick_query.md redis sqlite Copyright © xuegangliu 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-02-26 18:19:34 "},"database/memcached/":{"url":"database/memcached/","title":"memcached","keywords":"","body":"memcache记录 [x] memcache_base.md Copyright © xuegangliu 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-02-26 18:19:34 "},"database/mongo/":{"url":"database/mongo/","title":"mongo","keywords":"","body":"mongo记录 [ ] 无文档 Copyright © xuegangliu 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-02-26 18:19:34 "},"database/mysql/":{"url":"database/mysql/","title":"mysql","keywords":"","body":"mysql记录 [ ] 无文档 Copyright © xuegangliu 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-02-26 18:19:34 "},"database/oracle/":{"url":"database/oracle/","title":"oracle","keywords":"","body":"oracle记录 [x] oracle_base.md [ ] oracle_funs.md [x] oracle_system.md [x] quick_query.md Copyright © xuegangliu 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-02-26 18:19:34 "},"database/oracle/oracle_base.html":{"url":"database/oracle/oracle_base.html","title":"oracle_base","keywords":"","body":"基础 start with connect by (nocycle) prior 递归查询用法 start with 子句：遍历起始条件，有个小技巧，如果要查父结点，这里可以用子结点的列，反之亦然。 connect by 子句：连接条件。关键词prior，prior跟父节点列parentid放在一起，就是往父结点方向遍历； prior跟子结点列subid放在一起，则往叶子结点方向遍历，parentid、subid两列谁放在“=”前都无所谓，关键是prior跟谁在一起。 nocycle 避免环形死循环 Merge into 判断表中有没有符合on（）条件中的数据，有了就更新数据，没有就插入数据 merge into 目标表 a using 源表 b on(a.条件字段1=b.条件字段1 and a.条件字段2=b.条件字段2 ……) when matched then update set a.更新字段=b.字段 when not macthed then insert into a(字段1,字段2……)values(值1,值2……) when not macthed then,条件可选择,即至更新数据或只插入数据 Copyright © xuegangliu 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-02-26 18:19:34 "},"database/oracle/oracle_system.html":{"url":"database/oracle/oracle_system.html","title":"oracle_system","keywords":"","body":"oracle常用系统信息查询 系统信息查询 v$controlfile 控制文件信息 v$datafile 数据文件信息 v$session 会话信息 数据库表信息 DBA_TABLES、ALL_TABLES 数据库表信息 DBA_TAB_COLUMNS、ALL_TAB_COLUMNS、USER_TAB_COLUMNS 数据库表的列信息 USER_TAB_COMMENTS、USER_COL_COMMENTS 数据库表、列注释 DBA_VIEWS、ALL_VIEWS、USER_VIEWS 视图 DBA_SEQUENCES、ALL_SEQUENCES、USER_SEQUENCES 序列 DBA_INDEXS、ALL_INDEXS、USER_INDEXS、DBA_IND_COLUMNS、ALL_IND_COLUMNS、USER_IND_COLUMNS 索引 用户 DBA_USERS、DBA_ROLES 用户、角色 DBA_PROFILES 配置 DBA_TABLESPACES 表空间 表信息 1.dba_开头表 dba_users 数据库用户信息 dba_segments 表段信息 dba_extents 数据区信息 dba_objects 数据库对象信息 dba_tablespaces 数据库表空间信息 dba_data_files 数据文件设置信息 dba_temp_files 临时数据文件信息 dba_rollback_segs 回滚段信息 dba_ts_quotas 用户表空间配额信息 dba_free_space 数据库空闲空间信息 dba_profiles 数据库用户资源限制信息 dba_sys_privs 用户的系统权限信息 dba_tab_privs 用户具有的对象权限信息 dba_col_privs 用户具有的列对象权限信息 dba_role_privs 用户具有的角色信息 dba_audit_trail 审计跟踪记录信息 dba_stmt_audit_opts 审计设置信息 dba_audit_object 对象审计结果信息 dba_audit_session 会话审计结果信息 dba_indexes 用户模式的索引信息 2.user_开头表 user_objects 用户对象信息 user_source 数据库用户的所有资源对象信息 user_segments 用户的表段信息 user_tables 用户的表对象信息 user_tab_columns 用户的表列信息 关于这个还涉及到两个常用的例子如下：2.1.Oracle中查询某个字段属于哪个表 select table_name,owner from dba_tab_columns t where t.COLUMN_NAME like upper('%username%');2.2.oracle中查询某个表的列数 select count(*) from user_tab_columns where table_name= upper('sys_operate') 注:这两个例子都用到了upper这个函数，是因为在这里表名得大写，否则查出的结果不是正确的 user_constraints 用户的对象约束信息 user_sys_privs 当前用户的系统权限信息 user_tab_privs 当前用户的对象权限信息 user_col_privs 当前用户的表列权限信息 user_role_privs 当前用户的角色权限信息 user_indexes 用户的索引信息 user_ind_columns 用户的索引对应的表列信息 user_cons_columns 用户的约束对应的表列信息 user_clusters 用户的所有簇信息 user_clu_columns 用户的簇所包含的内容信息 user_cluster_hash_expressions 散列簇的信息 3.v$开头表 v$database 数据库信息 v$datafile 数据文件信息 v$controlfile 控制文件信息 v$logfile 重做日志信息 v$instance 数据库实例信息 v$log 日志组信息 v$loghist 日志历史信息 v$sga 数据库SGA信息 v$parameter 初始化参数信息 v$process 数据库服务器进程信息 v$bgprocess 数据库后台进程信息 v$controlfile_record_section 控制文件记载的各部分信息 v$thread 线程信息 v$datafile_header 数据文件头所记载的信息 v$archived_log 归档日志信息 v$archive_dest 归档日志的设置信息 v$logmnr_contents 归档日志分析的DML DDL结果信息 v$logmnr_dictionary 日志分析的字典文件信息 v$logmnr_logs 日志分析的日志列表信息 v$tablespace 表空间信息 v$tempfile 临时文件信息 v$filestat 数据文件的I/O统计信息 v$undostat Undo数据信息 v$rollname 在线回滚段信息 v$session 会话信息 v$transaction 事务信息 v$rollstat 回滚段统计信息 v$pwfile_users 特权用户信息 v$sqlarea 当前查询过的sql语句访问过的资源及相关的信息 v$sql 与v$sqlarea基本相同的相关信息 v$sysstat 数据库系统状态信息 4.all_开头表 all_users 数据库所有用户的信息 all_objects 数据库所有的对象的信息 all_def_audit_opts 所有默认的审计设置信息 all_tables 所有的表对象信息 all_indexes 所有的数据库对象索引的信息 5.session_开头表 session_roles 会话的角色信息 session_privs 会话的权限信息 6.index_开头表 index_stats 索引的设置和存储信息 Copyright © xuegangliu 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-02-26 18:19:34 "},"database/redis/":{"url":"database/redis/","title":"redis","keywords":"","body":"redis记录 [ ] 无文档 Copyright © xuegangliu 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-02-26 18:19:34 "},"database/sqlite/":{"url":"database/sqlite/","title":"sqlite","keywords":"","body":"sqlite记录 [ ] 无文档 Copyright © xuegangliu 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-02-26 18:19:34 "},"java/":{"url":"java/","title":"java","keywords":"","body":"Java base java_concurrent.md java_package_look.md hibernate hibernate_base.md hibernate_lock.md log log4j_config.md rpc Copyright © xuegangliu 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-02-26 18:19:34 "},"java/base/":{"url":"java/base/","title":"base","keywords":"","body":"Java基础 [x] java_concurrent.md [x] java_package_look.md Copyright © xuegangliu 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-02-26 18:19:34 "},"java/base/java_concurrent.html":{"url":"java/base/java_concurrent.html","title":"java_concurrent","keywords":"","body":"线程安全 atomic(可变) 支持在单个变量上解除锁的线程安全编程 规则 get 具有读取 volatile 变量的内存效果。 set 具有写入（分配）volatile 变量的内存效果。 除了允许使用后续（但不是以前的）内存操作，其自身不施加带有普通的非 volatile 写入的重新排序约束，lazySet 具有写入（分配）volatile 变量的内存效果。在其他使用上下文中，当为 null 时（为了垃圾回收），lazySet 可以应用不会再次访问的引用。 weakCompareAndSet 以原子方式读取和有条件地写入变量但不 创建任何 happen-before 排序，因此不提供与除 weakCompareAndSet 目标外任何变量以前或后续读取或写入操作有关的任何保证。 compareAndSet 和所有其他的读取和更新操作（如 getAndIncrement）都有读取和写入 volatile 变量的内存效果。 关键字 volatile,基于反射更新类volatile字段的值 locks 为锁和等待条件提供 关键字 synchronized块结构机制,Lock实现其它以外的功能 Copyright © xuegangliu 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-02-26 18:19:34 "},"java/hibernate/hibernate_lock.html":{"url":"java/hibernate/hibernate_lock.html","title":"hibernate_lock","keywords":"","body":"锁机制 @author:xuegangliu @date:2019-02-14 排他性 类型:悲观锁、乐观锁 数据库锁 利用数据库的锁机制实现 oracle语句select ... for update for update对符合条件的数据进行加锁操作,针对当前的session for upadate of 表主键 子句用于多个表之间,对指定的表进行加锁 update nowait|for update wait 3 在获取锁之前已经被锁,返回错误|等待时间后进行锁获取 悲观锁 大部分依赖于数据库锁 Hibernate 的加锁模式有： LockMode.NONE ： 无锁机制。 LockMode.WRITE ： Hibernate 在 Insert 和 Update 记录的时候会自动获取。 LockMode.READ ： Hibernate 在读取记录的时候会自动获取。 注意:以上这三种锁机制一般由 Hibernate 内部使用，如 Hibernate 为了保证 Update过程中对象不会被外界修改，会在 save 方法实现中自动为目标对象加上 WRITE 锁。 LockMode.UPGRADE ：利用数据库的 for update 子句加锁。 LockMode. UPGRADE_NOWAIT ： Oracle 的特定实现，利用 Oracle 的 for update nowait 子句实现加锁。 实现方法 Criteria.setLockMode Query.setLockMode Session.lock 乐观锁 大多是基于数据版本（ Version ）记录机制实现 Hibernate 的加锁方式 进行数据事物的时候,判断数据版本是否一致,一致进行事物获取,不一致,重新获取数据再进行事物处理 对象映射object.xml中配置 optimistic-lock=\"xx\" optimistic-lock 属性有如下可选取值： none：无乐观锁 version：通过版本机制实现乐观锁 dirty：通过检查发生变动过的属性实现乐观锁 all：通过检查所有属性实现乐观锁 实现方法 ... // 操作事物时,对字段值进行累加 版本字段必须放在主键映射之后 Copyright © xuegangliu 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-02-26 18:19:34 "},"java/log/":{"url":"java/log/","title":"log","keywords":"","body":"log4j [x] log4j_config.md Copyright © xuegangliu 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-02-26 18:19:34 "},"java/log/log4j_config.html":{"url":"java/log/log4j_config.html","title":"log4j_config","keywords":"","body":"log4j配置 日志级别 OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL,一般使用(ERROR、WARN、INFO、DEBUG) properties配置 有缺陷 高级别的日志在低级别的日志中出现 # priority :debug> Method: %l ]%n%p:%m%n #debug log log4j.logger.debug=debug log4j.appender.debug=org.apache.log4j.DailyRollingFileAppender log4j.appender.debug.DatePattern='_'yyyy-MM-dd'.log' log4j.appender.debug.File=./src/com/hp/log/debug.log log4j.appender.debug.Append=true log4j.appender.debug.Threshold=DEBUG log4j.appender.debug.layout=org.apache.log4j.PatternLayout log4j.appender.debug.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss a} [Thread: %t][ Class:%c >> Method: %l ]%n%p:%m%n #warn log log4j.logger.warn=warn log4j.appender.warn=org.apache.log4j.DailyRollingFileAppender log4j.appender.warn.DatePattern='_'yyyy-MM-dd'.log' log4j.appender.warn.File=./src/com/hp/log/warn.log log4j.appender.warn.Append=true log4j.appender.warn.Threshold=WARN log4j.appender.warn.layout=org.apache.log4j.PatternLayout log4j.appender.warn.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss a} [Thread: %t][ Class:%c >> Method: %l ]%n%p:%m%n #error log4j.logger.error=error log4j.appender.error = org.apache.log4j.DailyRollingFileAppender log4j.appender.error.DatePattern='_'yyyy-MM-dd'.log' log4j.appender.error.File = ./src/com/hp/log/error.log log4j.appender.error.Append = true log4j.appender.error.Threshold = ERROR log4j.appender.error.layout = org.apache.log4j.PatternLayout log4j.appender.error.layout.ConversionPattern = %d{yyyy-MM-dd HH:mm:ss a} [Thread: %t][ Class:%c >> Method: %l ]%n%p:%m%n xml配置 --> --> --> --> --> --> --> --> --> 的定义可以将各个包中的类日志输出到不同的日志文件中--> --> --> --> Copyright © xuegangliu 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-02-26 18:19:34 "},"java/rpc/":{"url":"java/rpc/","title":"rpc","keywords":"","body":"Java远程调用 RPC [ ] WebService [ ] Hessian [ ] Dubbo Copyright © xuegangliu 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-02-26 18:19:34 "},"java/springboot/":{"url":"java/springboot/","title":"springboot","keywords":"","body":"springboot 文档 [ ] xxxx Copyright © xuegangliu 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-02-26 18:19:34 "},"others/":{"url":"others/","title":"others","keywords":"","body":"其它文档记录 [ ] share.md Copyright © xuegangliu 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-02-26 18:19:34 "},"others/share.html":{"url":"others/share.html","title":"share","keywords":"","body":"分享 资料 技术视频资料[https://pan.baidu.com/s/1mH-SRVnaOuV_MPNORMMWzQ 提取码：rx76] Copyright © xuegangliu 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-02-26 18:19:34 "},"server/":{"url":"server/","title":"server","keywords":"","body":"应用服务器 组件、容器服务器(jsp/servlet容器) Websphere IBM服务器(强项在均衡负载,但消耗资源非常厉害，门坎很高，决定于硬件，非常适合生产环境部署) Weblogic Tomcat(小型服务) jboss(需要的内存和硬盘空间比较小) Geronimo http容器 apache http IIS nginx Google Web Server lighttpd Copyright © xuegangliu 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-02-26 18:19:34 "},"server/blog_link.html":{"url":"server/blog_link.html","title":"blog_link","keywords":"","body":"文章 Websphere 服务器直接的区别 Copyright © xuegangliu 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-02-26 18:19:34 "},"server/webSphere/webSphere_base.html":{"url":"server/webSphere/webSphere_base.html","title":"webSphere_base","keywords":"","body":"websphere基本概念 什么是单元（Cell）？什么是节点（Node）？Node、Profile 与 Server 之间的关系是什么？ 答： 单元： 单元是整个分布式网络中一个或多个节点的逻辑分组。单元是一个配置概念，是管理员将节点间逻辑关联起来的实现方法。 管理员根据具体的业务环境，制定对其整体系统集成环境有意义的条件来定义和组织构成单元的节点。就一般情况来说，可以将单元看作是最大的作用域。 在 IBM WAS ND 产品中，管理配置数据都存储在 XML 文件中。单元保留了它每个节点中每台服务器的主配置文件。 同时每个节点和服务器也有其自己的本地配置文件。如果服务器已经属于单元，则对于本地节点或服务器配置文件的更改都是临时的，通过在本地提交更改生效时， 本地更改覆盖单元配置，但是当执行单元配置文档同步到节点的操作时，在单元级别上对主控服务器和主节点配置文件所作的更改将会替换对该节点所作的任何临时更改。 节点： 节点是受管服务器（Server）的逻辑分组。节点通常与具有唯一 IP 主机地址的逻辑或物理计算机系统对应，节点不能跨多台计算机。节点分为受管节点与非受管节点。 关于 Node、Profile 与 Server: 这三个概念比较容易混淆，我们拿出来对比说明：Node=Profile。Node 是管理上使用的概念，Profile 是实际的概要文件，它们代表同一事物。 Server 就是所谓的 Application Server Instance , 这是我们实际要布署 Application 的地方。 在IBM WAS ND 产品中受管节点的 Node Agent 目的就是让 Deployment Manager Server 可以透过 Node Agent 来管 Node (Profile) 中的 Application Server Instance， 一个 Node (Profile) 中可以有多个 Application Server Instance。 如果是非 ND 版本 , 则属于 Single Server 版本，那么一个 Node (Profile) 中只能有一个 Application Server Instance， 如果你希望在一台机器上有多个 Application Server Instance，那就只能透过创建多个 Profile (Node) 来达成，但这些 Node (Porfile) 彼此独立没有管理上的关系 (RelationShip)，只要使用的 TCP/IP Port 不要冲突即可 Copyright © xuegangliu 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-02-26 18:19:34 "},"web/":{"url":"web/","title":"web","keywords":"","body":"Copyright © xuegangliu 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-02-26 18:19:34 "}}